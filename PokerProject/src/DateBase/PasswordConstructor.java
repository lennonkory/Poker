package DateBase;

import java.io.UnsupportedEncodingException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;

/**
 * Generates and Controls passwords.
 * @author kory
 */
public class PasswordConstructor {
    
    private static final PasswordConstructor pc = new PasswordConstructor();
    private final SecureRandom securerandom;
    
    private PasswordConstructor(){
        securerandom = new SecureRandom();
    }
    
    public static PasswordConstructor getPasswordConstructor(){
        return pc;
    }
    
    /**
    * Converts a byte array to strings
    * @param b
    * @return */  
    public String byteToString(byte b[]){
        String s = "";
        
        for(byte i : b){
            s+=i;
        }
        
        return s;
    }
    
    private byte[] stringToByte(String s){
    
        byte nb[] = new byte[s.length()];
        
        for(int i = 0; i < s.length(); i++){
            int n = Integer.parseInt(Character.toString(s.charAt(i)));
            nb[i] = (byte)n;
        }
        
        return nb;
        
    }
    
    private byte [] modByte(byte b[]){
    
        byte newByte[] = new byte[b.length];
        
        for(int i = 0; i < b.length; i++ ){
            newByte[i] = (byte) Math.abs( (b[i] % 10));
        }
        
        return newByte;
        
    }
    
    private boolean isEqual(byte one[], byte two[]){
    
        if(one.length != two.length){
            return false;
        }
        
        for(int i = 0 ; i < one.length; i++){
            if(one[i] != two[i]){
                return false;
            }
        }
        
        return true;
        
    }
    
    /**
     * Generates a hash number based on a random salt and the users password
     * @param salt a random byte array. Generally created from getSalt
     * @param pass the password the user wishes to store
     * @return the hash as a byte array
     */
    public byte[] hash(byte salt[], String pass) throws NoSuchAlgorithmException, UnsupportedEncodingException, InvalidKeySpecException{
        
        salt = modByte(salt);
        PBEKeySpec p =  new PBEKeySpec(pass.toCharArray(), salt, 1000, 256);
        SecretKeyFactory skf = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1");
        return modByte(skf.generateSecret(p).getEncoded());
    }
    
    public String getStringSalt(int size){
        return byteToString(getSalt(size));
    }
    
    public String getStringSalt(){
        return byteToString(getSalt());
    }
    
    /**
     * Creates and fills a byte array with randomly generated bytes.
     * @param saltSize size of the byte array
     * @return randomly generated byte array*/
    public byte[] getSalt(int saltSize){
   
        byte salt [] = new byte[saltSize];
        securerandom.nextBytes(salt);
        
        return modByte(salt);
        
    }
    
    /**
     * Creates and fills a byte array with randomly generated bytes.
     * Default array size is 32
     * @return */
    
    public byte[] getSalt(){
   
        byte salt [] = new byte[32];
        securerandom.nextBytes(salt);
        
        return modByte(salt);
        
    }

    /**
     * Compares the password the user entered with the one stored in the database
     * @param saltStr users salt in string formate
     * @param userPassword the passed the user is attempting to use
     * @param dataPassword the password stored in the database
     * @return true if the passwords match*/
    public boolean compare(String saltStr, String userPassword, String dataPassword) {
        
        byte userSalt[] = stringToByte(saltStr);
        
        byte hashed[] = null;
        
        try {
            hashed = hash(userSalt, userPassword);
            System.out.println("Hashed: " + byteToString(hashed));
            System.out.println("Salt: " + byteToString(userSalt));
        } catch (NoSuchAlgorithmException | UnsupportedEncodingException | InvalidKeySpecException ex) {
            Logger.getLogger(PasswordConstructor.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        return byteToString(hashed).equals(dataPassword);
        
    }

}
